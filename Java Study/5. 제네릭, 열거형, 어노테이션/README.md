# 제네릭
- 다양한 타입의 객체들을 다루는 메서드나 컬렉션 클래스에서 객체의 타입을 컴파일 시에 체크를 해주는 기능
- 객체의 타입 안정성을 높이고 형변환의 번거로움이 줄어든다는 장점

## 객체 생성과 사용
```java
// T: 타입 변수, 임의의 참조형 타입을 의미
class Box<T> {
    T item;
    
    void setItem(T item) {this.item = item;}
    T getItem() {return item;}
}
```

- 제네릭 클래스의 객체를 생성할 때는 참조변수와 생성자에 타입 T 대신 사용될 실제 타입을 지정하고, 참조변수와 생성자에 대입된 타입은 일치해야 한다. (제네릭 타입 호출)<br>
`Box<String> box = new Box<String>();`
- 두 제네릭 클래스의 타입이 상속관계에 있고, 대입된 타입이 같은 것은 괜찮다.<br>
`Box<Apple> appleBox = new FruitBox<Apple>();`

<br>

## 주의점
- T는 인스턴스 변수로 간주되기 때문에 static 멤버에 타입 변수 T를 사용할 수 없다.
  - static 멤버는 대입된 타입의 종류에 관계없이 동일한 것이어야 한다.
- 제네릭 배열 타입의 참조변수를 선언하는 것은 가능하지만, 제네릭 타입의 배열은 생성할 수 없다.
  - new 연산자는 컴파일 시점에 타입 T가 무엇인지 정확히 알아야 하기 때문
  - 같은 이유로 instanceof 연산자도 T를 피연산자로 사용할 수 없다.

```java
class Box<T> {
    T[] itemArr; // T 타입의 배열을 위한 참조변수, OK
    
    T[] toArray() {
        T[] tmpArr = new T[itemArr.length]; // 제네릭 타입의 배열, 에러 발생
        return tmpArr;
    }
}
```

- 제네릭 배열을 생성해야 할 때는, `Reflection API의 newInstance()`와 같이 동적으로 객체를 생성하는 메서드로 배열을 생성하거나,
- `Object 배열을 생성해서 복사한 다음에 T[]로 형변환`하는 방법을 사용한다.
```java
class ArrayList<E> implements List<E> {
    
    Object[] arr;
    
    @Override
    @SuppressWarnings("unchecked")
    public <T> T[] toArray(T[] a) {
        
        if (a.length < size) {
            return (T[]) Arrays.copyOf(arr, size, a.getClass());
        }

        System.arraycopy(arr, 0, a, 0, size);
        return a;
    }
}
```

<br>

## 제네릭 클래스 제한하기
- 제네릭 타입에 `extends`를 사용하면, 특정 타입의 자손들만 대입할 수 있게 제한할 수 있다.
- 인터페이스를 구현해야 한다는 제약이 필요할 때도 extends 사용<br>
`Class FruitBox<T extends Fruit>`

<br>

#### 와일드 카드
> &#60;? extends T&#62; : 와일드 카드의 상한 제한, T와 그 자손들만 가능  
> &#60;? super T&#62; : 와일드 카드의 하한 제한, T와 그 조상들만 가능  
> &#60;?&#62; : 제한 없음, 모든 타입 가능 (&#60;? extends Object&#62; 와 동일)

<br>

## 제네릭 메서드
- 메서드의 선언부에 제네릭 타입이 선언된 메서드로, 제네릭 타입은 반환 타입 바로 앞에 선언한다.
- static 멤버에는 타입 매개변수를 사용할 수 없지만, 메서드에 제네릭 타입을 선언하고 사용하는 것은 가능하다.
  - 메서드에 선언된 제네릭 타입은 지역변수를 선언한 것과 같다.

<br>

## 제네릭 타입의 형변환
- 와일드 카드가 포함된 제네릭 타입으로 형변환은 가능하다.
```java

```

<br>

# 열거형
- 서로 관련된 상수를 편리하게 선언하기 위한 것으로, 여러 상술르 정의할 때 사용한다.
- 자바의 열거형은 타입에 안전한 열거형으로, 실제 값이 같아도 타입이 다르면 컴파일 에러가 발생한다.
```java

```

- 열거형 상수 간의 비교에는 ==을 사용할 수 있지만, 비교 연산자는 사용할 수 없고 compareTo()는 사용가능하다.

<br>

## Enum 클래스
- 모든 열거형의 조상

|메서드|설명|
|---|---|
|Class<E> getDeclaringClass()|열거형의 Classs 객체 반환|
|String name()|열거형 상수의 이름을 문자열로 반환|
|int ordinal()|열거형 상수가 정의된 순서 반환|
|T valueOf(Class<T> enumType, String name)|지정된 열거형에서 name과 일치하는 열거형 상수 반환|

<br>

# 어노테이션
- 주석처럼 프로그래밍 언어에 영향을 미치지 않으면서, 다른 프로그램에게 유용한 정보를 제공한다.
- JDK에서 제공하는 표준 어노테이션은 주로 컴파일러를 위한 것으로 컴파일러에게 유용한 정보를 제공하고,
- 새로운 어노테이션을 정의할 때 사용하는 메타 어노테이션을 제공한다.

<br>

## 표준 어노테이션
#### @Override
- 메서드 앞에만 붙일 수 있으며, 조상의 메서들르 오버라이딩하는 것이라는 걸 컴파일러에게 알려주는 역할
- 컴파일러가 같은 이름의 메서드가 조상에 있는지 확인하고 없으면 에러메시지 출력

#### @Deprecated
- 더 이상 사용되지 않는 필드나 메서드에 붙이며, 이 어노테이션이 붙은 대상은 다른 것으로 대체되었으니 더 이상 사용하지 않는다는 것을 권한다는 의미
- 기존의 것 대신 새로 추가된 개선된 기능을 사용하도록 유도

#### @FunctionalInterface
- 함수형 인터페이스를 선언할 때 붙이며, 컴파일러가 함수형 인터페이스를 올바르게 선언했는지 확인하고 잘못된 경우 에러를 발생시킨다.

#### @SuppressWarning
- 컴파일러가 보여주는 경고 메시지가 나타나지 않게 억제해준다.

|경고 메시지|설명|
|---|---|
|deprecation|@Deprecated가 붙은 대상을 사용해서 발생하는 경고 억제|
|unchecked|제네릭으로 타입을 지정하지 않았을 때 발생하는 경고 억제|
|rawtypes|제네릭을 사용하지 않아서 발생하는 경고 억제|
|varargs|가변인자의 타입이 제네릭 타입일 때 발생하는 경고 억제|

#### @SafeVarargs
- 메서드에 선언된 가변인자의 타입이 non-reifiable 타입일 경우, 해당 메서드를 선언하는 부분과 호출하는 부부에서 unchecked 경고가 발생하는데,
- 해당 코드에 문제가 없는 경우 이러한 경고를 억제하기 위해 사용한다.
- static이나 final이 붙은 메서드와 생성자에만 붙일 수 있다. (오버라이드될 수 있는 메서드에는 사용할 수 없다는 뜻)
