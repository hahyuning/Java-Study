# 컬렉션 프레임워크

## 핵심 인터페이스

#### Collection
- List와 Set 인터페이스의 공통된 부분을 뽑아서 정의한 인터페이스
- Map 인터페이스는 다른 형태로 컬렉션을 다루기 때문에 같은 상속계층도에 포함되지 않는다.
- 컬렉션 클래스에 저장된 데이터를 읽고, 추가하고 삭제하는 등 컬렉션을 다루는데 가장 기본적인 메서드들을 정의

---

#### List
- 순서가 있는 데이터의 집합으로, 데이터의 중복을 허용한다.
- 구현 클래스: ArrayList, LinkedList, Stack, Vector 등

#### Set
- 순서를 유지하지 않는 데이터의 집합으로, 데이터의 중복을 허용하지 않는다.
- 구현 클래스: HashSet, TreeSet 등

#### Map
- 키와 값의 쌍으로 이루어진 데이터의 집합
- 순서는 유지되지 않으며, 키는 중복을 허용하지 않고, 값은 중복을 허용한다.
  - value() 의 반환타입은 Collection, keySet() 의 반환타입은 Set
- 구현 클래스: HashMap, TreeMap, Hashtable, Properties 등

> 컬렉션 프레임워크의 모든 컬렉션 클래스들은 List, Set, Map 중 하나를 구현하고 있다.

---

#### Map.Entry 
- Map 인터페이스의 내부 인터페이스
- Map에 저장되는 key-value 쌍을 다루기 위해 내부적으로 Entry 인터페이스를 정의해 놓았다.
```java
public interface Map {
    ...
    public static interface Entry {
        Object getKey(); // Entry의 key 객체를 반환
        Object getValue(); // Entry의 value 객체를 반환
        Object setValue(Object value); // Entry의 value 객체를 지정된 객체로 변환
        
        boolean equals(Object o); // 동일한 Entry인지 비교
        int hashCode(); // Entry의 해시코드 반환
        ...
    }
}
```

<br>

## 1. ArrayList
- List 인터페이스를 구현한 클래스로, 데이터의 저장순서가 유지되고 중복을 허용한다.
- Object 배열을 이용해서 데이터를 순차적으로 저장하며, 모든 종류의 객체를 담을 수 있다.
- 배열에 더 이상 저장할 공간이 없으면 보다 큰 배열을 생성해서 기존에 배열에 저장된 내용을 새로운 배열에 복사한다.
  - ArrayList을 생성할 때, 저장할 요소의 개수를 고려해서 실제 저장할 개수보다 약간 여유있는 크기로 하는 것이 좋다.
- 인덱스를 통해 데이터를 읽어오고 순차적으로 데이터를 저장하는 데는 효율이 좋지만, 배열의 중간에 객체를 추가하거나 삭제하는 경우에는 다른 데이터의 위치를 이동시켜줘야 한다.
  - 데이터 추가, 조회: O(1)
  - 데이터 삽입, 삭제: O(N)

#### 장점
- 가장 기본적인 형태의 자료구조로 구조가 간단하며 사용하기 쉽다.
- 각 요소들이 연속적으로 메모리 상에 존재하기 때문에 데이터를 읽어 오는데 걸리는 시간(접근시간)이 가장 빠르다.
- `인덱스가 n인 데이터의 주소 = 배열의 주소 + n * 데이터 타입의 크기`

#### 단점
- 크기를 변경할 때 새로운 배열을 생성해서 데이터를 복사해야 한다.
- 비순차적인 데이터의 추가 또는 삭제하는 과정에 다른 데이터들을 복사해서 이동해야 하므로 시간이 많이 걸린다.

<br>

> #### 배열의 복사에 걸리는 시간
> - ArrayList는 배열 크기 조절 인자가 2인 가변 크기 배열로, 배열이 가득 차는 순간 배열의 크기를 두 배로 늘린다.
> - 크기를 두 배로 늘리는 시간은 O(N) 이지만, 자주 발생하는 일이 아니라서 상환 입력 시간으로 계산했을 때 O(1)
> 
> > N 개의 원소를 삽입하기 위해서 복사해야 하는 원소의 총 개수는 N/2 + N/4 + ... + 1로 N보다 작다.<br>
> > 따라서 N개의 원소를 삽입할 때 소요되는 작업은 O(N)이 되고, 평균적으로 각 삽입은 O(1)이 소요된다. 

<br>

## 2. LinkedList
- 불연속적으로 존재하는 데이터를 서로 연결한 형태의 자료구조
- 각 요소(node)들은 자신과 연결된 다음 노드에 대한 참조와 데이터로 구성되어 있다.
```java
class Node {
    Node next;
    Object data;
}
```

#### 데이터 삭제
- 삭제하고자 하는 요소의 이전 요소가 삭제하고자 하는 요소의 다음 요소를 참조하도록 변경
- 배열처럼 데이터를 이동하기 위해 복사하는 과정이 없기 때문에 속도가 매우 빠르다.

#### 데이터 추가
- 새로운 요소를 생성한 다음 추가하고자 하는 위치의 이전 요소의 참조를 새로운 요소에 대한 참조로 변경하고, 새로운 요소가 그 다음 요소를 참조하도록 변경
- 속도가 매우 빠르다.

#### 데이터 조회
- 불연속적으로 위치한 각 요소들이 서로 연결된 것이라 처음부터 n번째 데이터까지 차례대로 따라가야만 원하는 데이터를 얻을 수 있다.
- 저장해야 하는 데이터의 개수가 많아질수록 데이터를 읽어 오는 시간이 길어진다.

<br>

### 2-1. 더블 링크드 리스트
- 링크드 리스트는 이동방향이 단방향이기 때문에 다음 요소에 대한 접근은 쉽지만 이전 요소에 대한 접근이 어렵다.
- 더블 링크드 리스트는 링크드 리스트에 참조변수를 하나 추가해 이전 요소에 대한 참조가 가능하도록 보완한 것
- 실제 LinkedList는 더블 링크드 리스트로 구현되어 있다.

### 2-2. 더블 써큘러 링크드 리스트
- 더블 링크드 리스트의 접근성을 향상시킨 것으로, 첫 번째 요소와 마지막 요소를 서로 연결시킨 것

<br>

## 3. Stack과 Queue

### 3-1. Stack
- 마지막에 저장한 데이터를 가장 먼저 꺼내는 LIFO 구조
- 순차적으로 데이터를 추가하고 삭제하므로, ArrayList와 같은 배열 기반의 컬렉션 클래스로 구현
- 자바에서는 스택을 Stack 클래스로 구현하여 제공
- 활용: 수식계산, 수식괄호검사, 워드프로세서의 undo/redo, 웹브라으라우저의 뒤로/앞으로, 함수호출 등

### 3-2. Queue
- 처음에 저장한 데이터를 가장 먼저 꺼내는 FIFO 구조
- 데이터를 꺼낼 때 항상 첫 번째 저장된 데이터를 삭제하므로, LinkedList로 구현
- 큐는 Queue 인터페이스를 구현한 클래스 중 하나를 선택해서 사용
- 활용: 최근사용문서, 인쇄작업 대기목록, 버퍼 등

### 3-3. PriorityQueue
- Queue 인터페이스의 구현체 중 하나로, 저장한 순서에 관계없이 우선순위가 높은 것부터 꺼낸다.
- null은 저장할 수 없다.
- 저장공간으로 배열을 사용하며, 각 요소를 힙이라는 자료구조으 ㅣ형태로 저장한다.

### 3-4. Deque
- 한 쪽 끝으로만 추가/삭제할 수 있는 Queue와 달리, 양쪽 끝에 추가/삭제가 가능하다.
- Deque의 조상은 Queue이며, 구현체로는 ArrayDeque와 LinkedList 등이 있다.
- 덱은 스택과 큐를 하나로 합쳐놓은 것과 같으며, 스택으로 사용할 수도 있고 큐로 사용할 수도 있다.


<br>

## 4. Iterator
- 컬렉션에 저장된 요소에 저근하는데 사용되는 인터페이스
- Collection 인터페이스에 Iterator(Iterator를 구현한 클래스의 인스턴스)를 반환하는 iterator()를 정의해 놓았다.
- 컬렉션 클래스에 대해 iterator()를 호출하여 Iterator를 얻은 다음 반복문을 사용해서 컬렉션 클래스의 요소를 읽어올 수 있다.
- Iterator를 사용해서 컬렉션의 요소를 읽어오는 방법을 표준화함으로써, 코드의 일관성을 유지하여 재사용성을 극대화할 수 있다.

<br>

|메서드|설명|
|---|---|
|boolean hasNext()|읽어올 요소가 남아있는지 확인|
|Object next()|다음 요소를 읽어오는 메서드로, 호출하기 전 hasNext()를 호출해서 읽어올 요소가 있는지 확인하는 것이 안전|
|void remove()|next()로 읽어온 요소를 삭제하며, **next()를 호출한 다음에 remove()를 호출해야 한다.**|

```java
List list = new ArrayList();
Iterator iter = list.iterator();

while (it.hasNext()) {
    System.out.println(it.next());
}
```

<br>

- Map 인터페이스를 구현한 컬렉션 클래스는 iterator()를 직접 호출할 수 없고, keySet()이나 entrySet()과 같은 메서드를 통해 키와 값을 각각 따로 Set 형태로 얻어온 후에
다시 iterator()를 호출해야 Iterator을 얻을 수 있다.
- Set 클래스들은 각 요소간의 순서가 유지되지 않기 때문에 Iterator를 통해서 저장된 요소들을 읽어와도 처음에 저장된 순서와 같지 않다.
```java
Map map = new HashMap();

Iterator iter = map.entrySet().iterator();
```

<br>

#### ListIterator
- Iterator를 상속받아서 기능을 추가한 것으로, 양방향으로 이동이 가능하다.
- ArrayList나 LinkedList와 같이 List 인터페이스를 구현한 컬렉션에서만 사용 가능
- 이동하기 전에 반드시 hasNext()나 hasPrevious()를 호출해서 이동할 수 있는지 확인해야 한다.

<br>

## 5. Arrays
배열을 다루는데 유용한 메서드가 정의되어 있는 클래스
