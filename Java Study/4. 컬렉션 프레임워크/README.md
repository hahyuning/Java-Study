# 컬렉션 프레임워크

## 핵심 인터페이스

#### Collection
- List와 Set 인터페이스의 공통된 부분을 뽑아서 정의한 인터페이스
- Map 인터페이스는 다른 형태로 컬렉션을 다루기 때문에 같은 상속계층도에 포함되지 않는다.
- 컬렉션 클래스에 저장된 데이터를 읽고, 추가하고 삭제하는 등 컬렉션을 다루는데 가장 기본적인 메서드들을 정의

---

#### List
- 순서가 있는 데이터의 집합으로, 데이터의 중복을 허용한다.
- 구현 클래스: ArrayList, LinkedList, Stack, Vector 등

#### Set
- 순서를 유지하지 않는 데이터의 집합으로, 데이터의 중복을 허용하지 않는다.
- 구현 클래스: HashSet, TreeSet 등

#### Map
- 키와 값의 쌍으로 이루어진 데이터의 집합
- 순서는 유지되지 않으며, 키는 중복을 허용하지 않고, 값은 중복을 허용한다.
  - value() 의 반환타입은 Collection, keySet() 의 반환타입은 Set
- 구현 클래스: HashMap, TreeMap, Hashtable, Properties 등

> 컬렉션 프레임워크의 모든 컬렉션 클래스들은 List, Set, Map 중 하나를 구현하고 있다.

---

#### Map.Entry 
- Map 인터페이스의 내부 인터페이스
- Map에 저장되는 key-value 쌍을 다루기 위해 내부적으로 Entry 인터페이스를 정의해 놓았다.
```java
public interface Map {
    ...
    public static interface Entry {
        Object getKey(); // Entry의 key 객체를 반환
        Object getValue(); // Entry의 value 객체를 반환
        Object setValue(Object value); // Entry의 value 객체를 지정된 객체로 변환
        
        boolean equals(Object o); // 동일한 Entry인지 비교
        int hashCode(); // Entry의 해시코드 반환
        ...
    }
}
```

<br>

## 1. ArrayList
- List 인터페이스를 구현한 클래스로, 데이터의 저장순서가 유지되고 중복을 허용한다.
- Object 배열을 이용해서 데이터를 순차적으로 저장하며, 모든 종류의 객체를 담을 수 있다.
- 배열에 더 이상 저장할 공간이 없으면 보다 큰 배열을 생성해서 기존에 배열에 저장된 내용을 새로운 배열에 복사한다.
  - ArrayList을 생성할 때, 저장할 요소의 개수를 고려해서 실제 저장할 개수보다 약간 여유있는 크기로 하는 것이 좋다.
- 인덱스를 통해 데이터를 읽어오고 순차적으로 데이터를 저장하는 데는 효율이 좋지만, 배열의 중간에 객체를 추가하거나 삭제하는 경우에는 다른 데이터의 위치를 이동시켜줘야 한다.
  - 데이터 추가, 조회: O(1)
  - 데이터 삽입, 삭제: O(N)

#### 장점
- 가장 기본적인 형태의 자료구조로 구조가 간단하며 사용하기 쉽다.
- 각 요소들이 연속적으로 메모리 상에 존재하기 때문에 데이터를 읽어 오는데 걸리는 시간(접근시간)이 가장 빠르다.
- `인덱스가 n인 데이터의 주소 = 배열의 주소 + n * 데이터 타입의 크기`

#### 단점
- 크기를 변경할 때 새로운 배열을 생성해서 데이터를 복사해야 한다.
- 비순차적인 데이터의 추가 또는 삭제하는 과정에 다른 데이터들을 복사해서 이동해야 하므로 시간이 많이 걸린다.

<br>

> #### 배열의 복사에 걸리는 시간
> - ArrayList는 배열 크기 조절 인자가 2인 가변 크기 배열로, 배열이 가득 차는 순간 배열의 크기를 두 배로 늘린다.
> - 크기를 두 배로 늘리는 시간은 O(N) 이지만, 자주 발생하는 일이 아니라서 상환 입력 시간으로 계산했을 때 O(1)
> 
> > N 개의 원소를 삽입하기 위해서 복사해야 하는 원소의 총 개수는 N/2 + N/4 + ... + 1로 N보다 작다.<br>
> > 따라서 N개의 원소를 삽입할 때 소요되는 작업은 O(N)이 되고, 평균적으로 각 삽입은 O(1)이 소요된다. 

<br>

## 2. LinkedList
- 불연속적으로 존재하는 데이터를 서로 연결한 형태의 자료구조
- 각 요소(node)들은 자신과 연결된 다음 노드에 대한 참조와 데이터로 구성되어 있다.
```java
class Node {
    Node next;
    Object data;
}
```

#### 데이터 삭제
- 삭제하고자 하는 요소의 이전 요소가 삭제하고자 하는 요소의 다음 요소를 참조하도록 변경
- 배열처럼 데이터를 이동하기 위해 복사하는 과정이 없기 때문에 속도가 매우 빠르다.

#### 데이터 추가
- 새로운 요소를 생성한 다음 추가하고자 하는 위치의 이전 요소의 참조를 새로운 요소에 대한 참조로 변경하고, 새로운 요소가 그 다음 요소를 참조하도록 변경
- 속도가 매우 빠르다.

#### 데이터 조회
- 불연속적으로 위치한 각 요소들이 서로 연결된 것이라 처음부터 n번째 데이터까지 차례대로 따라가야만 원하는 데이터를 얻을 수 있다.
- 저장해야 하는 데이터의 개수가 많아질수록 데이터를 읽어 오는 시간이 길어진다.

<br>

### 2-1. 더블 링크드 리스트
- 링크드 리스트는 이동방향이 단방향이기 때문에 다음 요소에 대한 접근은 쉽지만 이전 요소에 대한 접근이 어렵다.
- 더블 링크드 리스트는 링크드 리스트에 참조변수를 하나 추가해 이전 요소에 대한 참조가 가능하도록 보완한 것
- 실제 LinkedList는 더블 링크드 리스트로 구현되어 있다.

### 2-2. 더블 써큘러 링크드 리스트
- 더블 링크드 리스트의 접근성을 향상시킨 것으로, 첫 번째 요소와 마지막 요소를 서로 연결시킨 것