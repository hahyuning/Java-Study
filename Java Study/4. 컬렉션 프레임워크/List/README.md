## 1. ArrayList
- List 인터페이스를 구현한 클래스로, 데이터의 저장순서가 유지되고 중복을 허용한다.
- Object 배열을 이용해서 데이터를 순차적으로 저장하며, 모든 종류의 객체를 담을 수 있다.
- 배열에 더 이상 저장할 공간이 없으면 보다 큰 배열을 생성해서 기존에 배열에 저장된 내용을 새로운 배열에 복사한다.
    - ArrayList을 생성할 때, 저장할 요소의 개수를 고려해서 실제 저장할 개수보다 약간 여유있는 크기로 하는 것이 좋다.
- 인덱스를 통해 데이터를 읽어오고 순차적으로 데이터를 저장하는 데는 효율이 좋지만, 배열의 중간에 객체를 추가하거나 삭제하는 경우에는 다른 데이터의 위치를 이동시켜줘야 한다.
    - 데이터 추가, 조회: O(1)
    - 데이터 삽입, 삭제: O(N)

#### 장점
- 가장 기본적인 형태의 자료구조로 구조가 간단하며 사용하기 쉽다.
- 각 요소들이 연속적으로 메모리 상에 존재하기 때문에 데이터를 읽어 오는데 걸리는 시간(접근시간)이 가장 빠르다.
- `인덱스가 n인 데이터의 주소 = 배열의 주소 + n * 데이터 타입의 크기`

#### 단점
- 크기를 변경할 때 새로운 배열을 생성해서 데이터를 복사해야 한다.
- 비순차적인 데이터의 추가 또는 삭제하는 과정에 다른 데이터들을 복사해서 이동해야 하므로 시간이 많이 걸린다.

<br>

> #### 배열의 복사에 걸리는 시간
> - ArrayList는 배열 크기 조절 인자가 2인 가변 크기 배열로, 배열이 가득 차는 순간 배열의 크기를 두 배로 늘린다.
> - 크기를 두 배로 늘리는 시간은 O(N) 이지만, 자주 발생하는 일이 아니라서 상환 입력 시간으로 계산했을 때 O(1)
>
> > N 개의 원소를 삽입하기 위해서 복사해야 하는 원소의 총 개수는 N/2 + N/4 + ... + 1로 N보다 작다.<br>
> > 따라서 N개의 원소를 삽입할 때 소요되는 작업은 O(N)이 되고, 평균적으로 각 삽입은 O(1)이 소요된다.

<br>

## 2. LinkedList
- 불연속적으로 존재하는 데이터를 서로 연결한 형태의 자료구조
- 각 요소(node)들은 자신과 연결된 다음 노드에 대한 참조와 데이터로 구성되어 있다.
```java
class Node {
    Node next;
    Object data;
}
```

#### 데이터 삭제
- 삭제하고자 하는 요소의 이전 요소가 삭제하고자 하는 요소의 다음 요소를 참조하도록 변경
- 배열처럼 데이터를 이동하기 위해 복사하는 과정이 없기 때문에 속도가 매우 빠르다.

#### 데이터 추가
- 새로운 요소를 생성한 다음 추가하고자 하는 위치의 이전 요소의 참조를 새로운 요소에 대한 참조로 변경하고, 새로운 요소가 그 다음 요소를 참조하도록 변경
- 속도가 매우 빠르다.

#### 데이터 조회
- 불연속적으로 위치한 각 요소들이 서로 연결된 것이라 처음부터 n번째 데이터까지 차례대로 따라가야만 원하는 데이터를 얻을 수 있다.
- 저장해야 하는 데이터의 개수가 많아질수록 데이터를 읽어 오는 시간이 길어진다.

<br>

### 2-1. 더블 링크드 리스트
- 링크드 리스트는 이동방향이 단방향이기 때문에 다음 요소에 대한 접근은 쉽지만 이전 요소에 대한 접근이 어렵다.
- 더블 링크드 리스트는 링크드 리스트에 참조변수를 하나 추가해 이전 요소에 대한 참조가 가능하도록 보완한 것
- 실제 LinkedList는 더블 링크드 리스트로 구현되어 있다.

### 2-2. 더블 써큘러 링크드 리스트
- 더블 링크드 리스트의 접근성을 향상시킨 것으로, 첫 번째 요소와 마지막 요소를 서로 연결시킨 것

> 참고: 런너 기법<br>
> 연결리스트를 순회할 때 두 개의 포인터를 동시에 사용하는 것으로, 한 포인터가 다른 포인터보다 앞서도록 한다.<br>
> 빠른 런너와 느린 런너의 속도를 2배로 설정하면 연결리스트에서 중간 지점을 구할 수 있다.

<br>

## 3. Stack과 Queue

### 3-1. Stack
- 마지막에 저장한 데이터를 가장 먼저 꺼내는 LIFO 구조
- 순차적으로 데이터를 추가하고 삭제하므로, ArrayList와 같은 배열 기반의 컬렉션 클래스로 구현
- 자바에서는 스택을 Stack 클래스로 구현하여 제공
- 활용: 수식계산, 수식괄호검사, 워드프로세서의 undo/redo, 웹브라으라우저의 뒤로/앞으로, 함수호출 등

### 3-2. Queue
- 처음에 저장한 데이터를 가장 먼저 꺼내는 FIFO 구조
- 데이터를 꺼낼 때 항상 첫 번째 저장된 데이터를 삭제하므로, LinkedList로 구현
- 큐는 Queue 인터페이스를 구현한 클래스 중 하나를 선택해서 사용
- 활용: 최근사용문서, 인쇄작업 대기목록, 버퍼 등

### 3-3. PriorityQueue
- Queue 인터페이스의 구현체 중 하나로, 저장한 순서에 관계없이 우선순위가 높은 것부터 꺼낸다.
- null은 저장할 수 없다.
- 저장공간으로 배열을 사용하며, 각 요소를 힙이라는 자료구조으 ㅣ형태로 저장한다.

### 3-4. Deque
- 한 쪽 끝으로만 추가/삭제할 수 있는 Queue와 달리, 양쪽 끝에 추가/삭제가 가능하다.
- Deque의 조상은 Queue이며, 구현체로는 ArrayDeque와 LinkedList 등이 있다.
- 덱은 스택과 큐를 하나로 합쳐놓은 것과 같으며, 스택으로 사용할 수도 있고 큐로 사용할 수도 있다.