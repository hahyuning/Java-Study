## 디자인 패턴
- 시스템을 만들기 위해서 전체 중 일부 의미있는 클래스들을 묶은 각각의 집합
- 반복되는 의미있는 집합을 정의하고 이름을 붙여서, 누가 이야기하더라도 동일한 의미의 패턴이 되도록 만들어 놓은 것
- 참고: GoF 패턴

#### MVC 모델
- 하나의 JSP나 스윙처럼 화면에 모든 처리로직을 모아두는 것이 아니라, 모델 역할, 뷰 역할, 컨트롤러 역할을 하는 클래스를 각각 만들어서 개발하는 모델

| 이름 | 역할 |
|--|--|
| 뷰 | - 사용자가 결과를 보거나 입력할 수 있는 화면<br> - 이벤트를 발생시키고, 이벤트의 결과를 보여주는 역할 |
| 컨트롤러 | - 뷰와 모델의 연결자<br> - 뷰에서 받은 이벤트를 모델로 연결하는 역할 |
| 모델 | - 뷰에서 입력된 내용을 저장, 관리, 수정하는 역할<br> - 이벤트에 대한 실질적인 처리를 하는 부분 |

> JSP 모델1
> - JSP에서 자바빈을 호출하고 데이터베이스에서 정보를 조회, 등록, 수정, 삭제 업무를 한 후 결과를 브라우저로 보내주는 방식
> - 간단하게 개발할 수 있다는 장점이 있지만, 개발 후 프로세스 변경이 생길 경우에 수정이 어렵다는 단점
> - 화면과 비즈니스 모델의 분업화가 어려워 개발자의 역량에 따라서 코드가 많이 달라질 수 있다.
> - 컨트롤러가 없다.

> JSP 모델2
> - MVC 모델을 정확하게 따른다.
> - 서블릿을 통해 요청을 하며, 서블릿이 컨트롤러의 역할을 수행한다.
<br>

#### J2EE 패턴
![image](https://user-images.githubusercontent.com/60869749/147656247-d09a8bd9-ba60-4068-8a1c-f59424da7829.png)

| 패턴 이름 | 설명 |
|--|--|
| Intercepting Filter | 요청 타입에 따라 다른 처리를 하기 위한 패턴 |
| Front Controller | 요청 전후에 처리하기 위한 컨트롤러를 지정하는 패턴 |
| View Helper | 프레젠테이션 로직과 상관 없는 비즈니스 로직을 헬퍼로 지정하는 패턴 |
| Composite View | 최소 단위의 하위 컴포넌트를 분리하여 화면을 구성하는 패턴 |
| Serivce to Worker | Front Controller와 View Helper 사이에 디스패처를 두어 조합하는 패턴 |
| Dispatcher View | Front Controller와 View Helper로 디스패처 컴포넌트를 형성하는 패턴 |
| **Business Delegate** | 비즈니스 서비스 접근을 캡슐화하는 패턴 |
| **Service Locator** | 서비스와 컴포넌트 검색을 쉽게 하는 패턴 |
| **Session Facade** | 비즈니스 티어 컴포넌트를 캡슐화하고, 원격 클라이언트에서 접근할 수 있는 서비스를 제공하는 패턴 |
| Composite Entity | 로컬 엔티티 빈과 POJO를 이용하여 큰 단위의 엔티티 객체를 구현 |
| **Transfer Object** | Value Object 패턴이라고도 부르며, 데이터를 전송하기 위한 객체에 대한 패턴 |
| Transfer Object Assembler | 하나의 VO로 모든 타입 데이터를 처리할 수 없으므로, 여러 VO를 조합하거나 변형한 객체를 생성하여 사용하는 패턴 |
| Value List Handler | 데이터 조회를 처리하고, 결과를 임시 저장하며, 결과 집합을 검색하여 필요한 항목을 선택하는 역할을 수행 |
| **Data Access Object** | DAO 라고도 부르며, DB에 접근을 전담하는 클래스를 추상화하고 캡슐화 |
| Service Activator | 비동기적 호출을 처리하기 위한 패턴 |

- 성능과 가장 밀접한 패턴은 Service Locator 패턴
- 성능에 직접적으로 많은 영향을 미치지는 않지만, Transfer Object는 애플리케이션 개발 시 반드시 사용해야 한다.

> [스프링 MVC 구현 예제](https://github.com/hahyuning/Servlet)
