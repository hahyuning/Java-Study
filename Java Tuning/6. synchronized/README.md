# synchronized

## 스레드
- 자바에서 클래스를 하나 수행시키거나 WAS를 기동하면, 서버에 자바 프로세스가 하나 생성된다.
- 하나의 프로세스에는 여러 개의 스레드가 생성된다. (1대 다 관계)
- 스레드는 경량 프로세스로, 프로세스에서 만들어 사용하고 있는 메모리를 공유한다.
  - 별개의 프로세스가 하나씩 뜨는 것보다 성능이나 자원 사용에 있어 효율적

### 스레드 구현
- 스레드의 구현은 Thread 클래스를 상속받는 방법과 Runnable 인터페이스를 구현하는 방법 두 가지가 있다.
  - Thread 클래스는 Runnable 인터페이스를 구현한 것
- Runnable 인터페이스를 구현하면 원하는 기능을 추가할 수 있지만, 해당 클래스를 수행할 때 별도의 스레드 객체를 생성해야 한다.
- 자바는 다중 상속이 불가능하므로, 스레드를 사용할 때 이미 상속받은 클래스가 존재한다면 Runnable 인터페이스를 구현해야 한다.

<br>

- Thread 클래스를 상속받은 경우에는 start 메서드를 호출하면 된다.
- Runnable 인터페이스를 구현한 경우에는 Thread 클래스의 Runnable 인터페이스를 매개변수로 받는 생성자를 사용해서 Thread 클래스를 만든 후 
start() 메서드를 호출해야 한다.
```java
public class RunThreads {
  public static void main(String[] args) {
    RunnableImpl ri = new RunnableImpl();
    ThreadExtends te = new ThreadExtends();

    new Thread(ri).start();
    te.start();
  }
}
```
<br>

### 스레드 대기
- 현재 진행 중인 스레드를 대기하도록 하기 위해서는 sleep(), wait(), join() 세 가지 메서드를 사용한다.
- 세 메서드 모두 예외를 던지도록 되어 있어 사용할 때는 반드시 예외 처리를 해주어야 한다.

#### wait()
- 모든 클래스의 부모 클래스인 Object 클래스에 선언
- 명시된 시간만큼 해당 스레드를 대기시키며, 매개변수를 지정하지 않으면 notify() 혹은 notifyAll() 메서드가 호출될 때까지 대기

#### sleep()
- 명시된 시간만큼 해당 스레드를 대기시킨다.
- static 메서드이기 때문에 반드시 스레드 객체를 통하지 않아도 사용할 수 있다.

#### join()
- 명시된 시간만큼 해당 스레드가 죽기를 기다린다.
- 아무런 매개변수를 지정하지 않으면 죽을 때까지 계속 대기한다.

<br>

### 스레드 대기 중지
#### interrupt()
- 스레드를 대기시키는 세 메서드를 모두 멈출 수 있는 유일한 메서드
- interrupt() 메서드가 호출되면 중지된 스레드에는 InterruptedException이 발생한다.
- 제대로 수행되었는지 확인하려면 interrupted() 메서드나 isInterrupted() 메서드를 호출한다.
  - interrupted() 메서드는 스레드의 상태를 변경시키지만, isInterrupted() 메서드는 스레드의 상태만 리턴
  - isAlive() 메서드는 해당 스레드가 살아있는지 확인하는 메서드
- interrupt() 메서드는 대기 상태일 때에만 해당 스레드를 중단시킨다.

#### notify()와 notifyAll()
- wait() 메서드를 멈추기 위한 메서드
- Object 클래스에 정의되어 있으며, wait() 메서드가 호출된 후 대기 상태로 바뀐 스레드를 깨운다.
- notify() 메서드는 객체의 모니터와 관련 있는 단일 스레드를 깨우며, notifyAll() 메서드는 객체의 모니터와 관련 있는 모든 스레드를 깨운다.

<br>

## synchronized
- synchronized는 하나의 객체에 여러 객체가 동시에 접근하여 처리하는 상황이 발생할 때 사용한다.
- 하나의 객체에 여러 요청이 동시에 달려들면 원하는 처리를 못하고 이상한 결과가 나올 수 있으므로, synchronized를 사용해서 동기화
- 메서드와 블록으로 사용할 수 있으며, 생성자의 식별자로는 사용할 수 없다.

#### 동기화를 사용하는 경우
- 하나의 객체를 여러 스레드에서 동시에 사용할 경우
- static으로 선언한 객체를 여러 스레드에서 동시에 사용할 경우

<br>

## java.util.concurrent 패키지
- Lock: 실행 중인 스레드를 간단한 방법으로 정지시켰다가 실행시킨다. 상호 참조로 인해 발생하는 데드락을 피할 수 있다.
- Executors: 스레드를 더 효츌적으로 관리할 수 있는 클래스들을 제공한다. 스레드 풀도 제공
- Concurrent 컬렉션: 동기화된 컬렉션의 클래스들을 제공한다.
- Atomic 변수: 동기화된 변수를 제공한다. 이 변수를 사용하면 synchronized 식별자를 메서드에 지정할 필요가 없다.