# 스레드
- 자바에서 클래스를 하나 수행시키거나 WAS를 기동하면 서버에 자바 프로세스가 하나 생성되고, 하나의 프로세스에는 여러 개의 스레드가 생성된다. (1대 다 관계)
- 스레드는 프로세스에서 만들어 사용하고 있는 메모리를 공유하기 때문에, 별개의 프로세스가 하나씩 뜨는 것보다 성능이나 자원 사용에 있어 효율적

## 스레드 구현
- 스레드의 구현은 Thread 클래스를 상속받는 방법과 Runnable 인터페이스를 구현하는 방법 두 가지가 있다.
  - Thread 클래스는 Runnable 인터페이스를 구현한 것
- Runnable 인터페이스를 구현하면 원하는 기능을 추가할 수 있지만, 해당 클래스를 수행할 때 별도의 스레드 객체를 생성해야 한다.
- 자바는 다중 상속이 불가능하므로, 스레드를 사용할 때 이미 상속받은 클래스가 존재한다면 Runnable 인터페이스를 구현해야 한다.

<br>

- Thread 클래스를 상속받은 경우에는 start() 메서드를 호출하면 된다.
- Runnable 인터페이스를 구현한 경우에는 Thread 클래스의 Runnable 인터페이스를 매개변수로 받는 생성자를 사용해서 Thread 클래스를 만든 후 start() 메서드를 호출해야 한다.
```java
public class RunThreads {
  public static void main(String[] args) {
    RunnableImpl ri = new RunnableImpl();
    ThreadExtends te = new ThreadExtends();

    new Thread(ri).start();
    te.start();
  }
}
```
<br>

## 스레드 상태 제어

### Running -> Waiting, Blocked
- 현재 실행 중인 스레드를 대기하도록 하기 위해서 sleep(), wait(), join() 세 가지 메서드를 사용한다.
- 세 메서드 모두 예외를 던지도록 되어 있어 사용할 때는 반드시 예외 처리를 해주어야 한다.

#### sleep()
- 명시된 시간만큼 현재 실행 중인 쓰레드를 대기시킨다.
- static 메서드이기 때문에 반드시 스레드 객체를 통하지 않아도 사용할 수 있다.
- sleep()에 의해 blocked 된 쓰레드는 지정된 시간이 다 되거나, interrupt()가 호출되면 실행대기 상태가 된다.

#### join()
- 명시된 시간만큼 다른 스레드가 작업을 수행하는 것을 기다리며, 아무런 매개변수를 지정하지 않으면 작업을 모두 마칠 때까지 기다린다.
- 작업 중에 다른 쓰레드의 작업이 먼저 수행되어야할 경우 사용한다.
- sleep()과의 차이점은 join()은 현재 쓰레드가 아닌 특정 쓰레드에 대해 동작하므로, static 메서드가 아니다.

#### wait()
- 명시된 시간만큼 해당 스레드를 대기시키며, 매개변수를 지정하지 않으면 notify() 혹은 notifyAll() 메서드가 호출될 때까지 대기한다.
- 동기화된 임계구역의 코드를 수행하다가 작업을 더 이상 진행할 상황이 아니면, wait()을 호출해서 쓰레드가 락을 반납하고 기다리게 한다.
  - 그러면 다른 쓰레드가 락을 얻어서 해당 객체에 대한 작업을 수행한다.
  - 나중에 작업을 진행할 수 있는 상황이 되면 notify()를 호출해서, 작업을 중단했던 쓰레드가 다시 락을 얻어 작업을 수행한다.


- Object 클래스에 선언되어 있으며, 동기화 블록 내에서만 사용할 수 있다.

<br>

### Waiting, Blocked -> Runnable
#### interrupt()
- 스레드를 대기시키는 세 메서드를 모두 멈출 수 있는 유일한 메서드
- interrupt() 메서드가 호출되면, 중지되 있던 스레드에는 InterruptedException이 발생하고 실행가능한 상태가 된다.
- 제대로 수행되었는지 확인하려면 interrupted() 메서드나 isInterrupted() 메서드를 호출한다.
  - `interrupt()`: 쓰레드의 interrupted 상태를 true로 변경하며, 대기 상태일 때에만 해당 스레드를 중단시킨다.
  - `interrupted()`: 쓰레드의 interrupted 상태 반환 후, false로 변경
  - `isInterrupted()`: 쓰레드의 interrupted 상태 반환
  - `isAlive()`: 해당 스레드가 살아있는지 확인하는 메서드

#### notify()와 notifyAll()
- wait() 메서드를 멈추기 위한 메서드
- Object 클래스에 정의되어 있으며, wait() 메서드가 호출된 후 대기 상태로 바뀐 스레드를 깨운다.
- notify() 메서드는 객체의 모니터와 관련 있는 단일 스레드를 깨우며, notifyAll() 메서드는 객체의 모니터와 관련 있는 모든 스레드를 깨운다.
  - notifyAll()이 호출된 객체의 waiting pool에 대기 중인 쓰레드만 깨워진다.

---

# synchronized
- 한 쓰레드가 진행 중인 작업을 다른 쓰레드가 간섭하지 못하게 함으로써 동기화 문제를 해결하고, 
- 동기화된 메서드나 블록에 들어간 쓰레드가 같은 락의 보호 하에 수행된 작업에 원자성을 보장해준다.
- synchronized 키워드는 메서드나 블록에 선언하며, 생성자의 식별자로는 사용할 수 없다.

### 동기화를 사용하는 경우
- 하나의 객체를 여러 스레드에서 동시에 사용할 경우
- static으로 선언한 객체를 여러 스레드에서 동시에 사용할 경우

<br>

## volatile
- 코어가 변수의 값을 읽어올 때 캐시가 아닌 메모리에서 읽어오기 때문에 캐시와 메모리 간의 불일치가 해결된다.
- volatile은 변수의 읽기나 쓰기를 원자화 할 뿐, 동기화하는 것은 아니다.

## java.util.concurrent 패키지
### 1. Lock
- 실행 중인 스레드를 간단한 방법으로 정지시켰다가 실행시킨다. 상호 참조로 인해 발생하는 데드락을 피할 수 있다.
- 자동적으로 lock의 잠금과 해제과 관리되는 synchronized 블럭과 달리, 수동으로 lock을 잠그고 해제해야 한다.

> ReentrantLock: 재진입 가능한 lock으로, 특정 조건에서 lock을 풀고 나중에 다시 lock을 얻어 임계구역으로 들어와서 이후의 작업을 수행할 수 있다.

### 2. Executors
스레드를 더 효츌적으로 관리할 수 있는 클래스들을 제공한다. 스레드 풀도 제공 

### 3. Concurrent 컬렉션
동기화를 내부에서 수행해 스레드에 안전한 컬렉션 클래스들을 제공한다.

### 4. Atomic 변수
- 동기화된 변수를 제공한다. 
- 이 변수를 사용하면 synchronized 식별자를 메서드에 지정할 필요가 없다.

> volatile은 스레드 간 통신 안전만을 지원하지만, Atomic 변수는 배타적 실행까지 지원